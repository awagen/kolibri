/**
  * Copyright 2021 Andreas Wagenmann
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */

package de.awagen.kolibri.datatypes.multivalues

import de.awagen.kolibri.datatypes.utils.{ParameterGenerator, PermutationUtils}
import de.awagen.kolibri.datatypes.values.OrderedValues

import scala.collection.immutable


/**
 * Implementation of OrderedMultiValues assuming a value grid, providing the methods to find n-th permutations
 * @param values - Seq of OrderedValues of any type
 */
case class GridOrderedMultiValues(values: Seq[OrderedValues[Any]]) extends OrderedMultiValues {

  val numberOfValuesPerParameter: immutable.Seq[Int] = values.map(x => x.totalValueCount).toList

  override def stepsForNthElementStartingFromFirstParam(n: Int): List[(Int, Int)] = {
    PermutationUtils.stepsForNthElementBackwardCalc(numberOfValuesPerParameter, n)
  }

  /**
    * provide series of parameter names
    *
    * @return
    */
  override def getParameterNameSequence: Seq[String] = ParameterGenerator.getParameterNameSequence(values)

  /**
    * Total number of parameter combinations in experiment
    *
    * @return
    */
  override def numberOfCombinations: Int = numberOfValuesPerParameter.product

  /**
    * find the nth element in the sequence generated by parameterSeries() call
    *
    * @param n
    */
  override def findNthElement(n: Int): Option[Seq[Any]] = {
    PermutationUtils.findNthElementForwardCalc(numberOfValuesPerParameter, n)
      .map(x => ParameterGenerator.indicesToValues(x, values))
  }

  /**
    * Find nrOfElements next elements starting from startElement (in case there are less elements remaining,
    * just return those)
    *
    * @param startElement
    * @param nrOfElements
    */
  override def findNNextElementsFromPosition(startElement: Int, nrOfElements: Int): Seq[Seq[Any]] = {
    ParameterGenerator.indicesSeqToValueSeq(PermutationUtils.findNNextElementsFromPosition(numberOfValuesPerParameter,
      startElement, nrOfElements), values)
  }

  override def addValue(value: OrderedValues[Any], prepend: Boolean): GridOrderedMultiValues = {
    if (prepend) GridOrderedMultiValues(value +: values) else GridOrderedMultiValues(values :+ value)
  }

  override def addValues(vals: Seq[OrderedValues[Any]], prepend: Boolean): GridOrderedMultiValues = {
    if (prepend) GridOrderedMultiValues(vals ++ values) else GridOrderedMultiValues(values ++ vals)
  }

  override def addValues(vals: OrderedMultiValues, prepend: Boolean): GridOrderedMultiValues = {
    addValues(vals.values, prepend)
  }

  /**
    * Remove value with given name.
    *
    * @param valueName
    * @return Tuple, first element being a new instance of OrderedMultiValues with Parameter removed, second being Boolean
    *         with value true if any parameter was removed false if the parameter was not found and thus the
    *         new OrderedMultiValues is just a copy of this here
    */
  override def removeValue(valueName: String): (OrderedMultiValues, Boolean) = {
    val filteredValues: Seq[OrderedValues[Any]] = values.filter(x => !x.name.eq(valueName))
    val foundValue: Boolean = filteredValues.size < values.size
    (GridOrderedMultiValues(filteredValues), foundValue)
  }
}
